[SCE CONFIDENTIAL DOCUMENT]
PlayStation(R)3 Programmer Tool Runtime Library 400.001
                  Copyright (C) 2006 Sony Computer Entertainment Inc.
                                                 All Rights Reserved.


Setting shader variables using the header output by sce-cgcdisasm


<Point of Sample Program>
  This sample uses a header into which the parameter information is output 
  via sce-cgcdisasm in order to communicate with a shader program without
  calling cellGcmCg* functions. In this sample, processes such as passing a
  constant and obtaining vertex attribute information for a vertex program, 
  and passing a constant and obtaining texture sampler information for a 
  fragment program are performed.
  This sample also uses the above mechanism to rewrite parameters of the 
  fragment program.

<Description of Sample Program>
  The resource information that was previously obtained from the vertex 
  program can be now obtained from the vpshader_params structure array 
  using cellGcmCgGetNamedParameter() and cellGcmCgGetParameterResource() 
  instead. The structure array is described within vpshader_params.h that 
  is generated by sce-cgcdisasm. For example, a variable defined as "position"
  within the vertex program is accessible as 
  vpshader_params[CELL_GCM_vpshader_params_position].res using
  CELL_GCM_vpshader_params_position. By subtracting the base value of the 
  vertex attribute "CG_ATTR0" from this value, a necessary index to call
  cellGcmSetVertexDataArray() can be calculated as shown below:

    cellGcmSetVertexDataArray(
        vpshader_params[CELL_GCM_vpshader_params_position].res-CG_ATTR0
        0,
        sizeof(Vertex),
        3,
        CELL_GCM_VERTEX_F,
        CELL_GCM_LOCATION_MAIN,
        getVertexOffset());

  Similarly, the texture sampler information that was previously obtained by 
  cellGcmCgGetNamedParameter() and cellGcmCgGetParameterResource() can be 
  obtained by obtaining the resource information of the fragment program from
  the header instead. For example, in the case of a sample that is defined with
  its variable name as "texture" within the fragment program like this sample,
  the texture setting can be done by obtaining the variable as 
  fpshader_params[CELL_GCM_fpshader_params_texture].res, and by subtracting the
  base value from it when being passed to the texture setting variable as shown
  below:

  setGcmTexture(fpshader_params[CELL_GCM_fpshader_params_texture].res-
  CG_TEXUNIT0);

  When stripping a shader binary using sce-cgcstrip with -a option assigned, 
  all the parameter information within the binary are deleted regardless of 
  whether each information is necessary or not. In the case of a vertex
  program, the initial value information that is set when
  cellGcmSetVertexProgram() is executed is also deleted. Therefore, the initial
  value to be used within the shader should be set by the application. When 
  dvindex of CellGcm_vpshader_params_Table has a value other than -1, it means 
  that the parameter has the initial value. In such case, the initial value 
  information will be held within vpshader_params_default_value structure array
  and dvindex will show an index to the initial value information. For instance,  when vpshader_params[CELL_GCM_vpshader_params_modelViewProj_0].dvindex has -1,  it means that modelViewProj[0] within the vertex program has the initial 
  value. This sample has a value 0 which means that it holds the initial value.
  Specifically, the initial value will be the value held in 
  vpshader_params_default_value[0] that is 
  {1.000000f, 0.000000f, 0.000000f, 0.000000f}. To set the initial value, check
  whether each parameter has an initial value, and when they do, use   
  cellGcmSetVertexProgramConstants() to perform the setting as follows:

    for (uint32_t i = 0; i < sizeof(vpshader_params)/sizeof(CellGcm_vpshader_params_Table); i++) {
        if (vpshader_params[i].dvindex != -1) {
            cellGcmSetVertexProgramConstants(
                    vpshader_params[i].resindex,
                    4,
                    vpshader_params_default_value[vpshader_params[i].dvindex].defaultvalue);
        }
    }

  When you want to update specific parameters that have a contiguous resource
  index like a matrix, you can perform the process as follows:

  cellGcmSetVertexProgramConstants(vpshader_params[CELL_GCM_vpshader_params_modelView_0].resindex, 16, M);

  When passing a value to the uniform parameter to be used by the fragment 
  program, RSX(R) have to write the value directly into the uniform parameter 
  area that is defined within the microcode area in the fragment program. 
  Normally, this is done by using cellGcmSetFragmentProgramParameter(). 
  However, to allow the application to control the uniform parameter, it is
  necessary to know the destination address into which the value is written.
  In the fragment program that is compiled by sce-cgc, such address information
  is described as an offset value from the start address of the microcode. 
  sce-cgcdisasm obtains the information and stores it into a structure array so
  that the application can set the uniform parameter directly.

  The offset value information described above is held in
  fpshader_params_const_offset structure array, and if the parameter is other 
  than -1, it means that ecindex member of fpshader_params_const_offset
  structure array contains the offset information. In this sample, such offset 
  information is contained in "light" parameter within the fragment program,
  and fpshader_params[CELL_GCM_fpshader_params_light].ecindex contains an index
  to fpshader_params_const_offset. In other words, the application can access 
  to the offset information by setting as fpshader_params_const_offset[fpshader_params[CELL_GCM_fpshader_params_light].ecindex].offset.   
  The number of offset information is variable because it depends  on how often
  the parameter is referred to within the fragment program. Therefore, 
  0xffffffff is defined as a termination identifier of the offset information
  which is from the value specified by the index until 0xffffffff is detected.
  In the case of "light", only 0x10 is deemed as the offset.
  The address that is actually rewritten can be calculated by adding the start 
  address of the microcode and the offset. Accordingly, const_addr will be
  computed as follows so that SPU will be notified of such address:

  uint32_t const_addr =
          getFpUcode() + fpshader_params_const_offset[fpshader_params[CELL_GCM_fpshader_params_light].ecindex].offset;
    setupSpuSharedBuffer(
            const_addr,
            (uint32_t)mainMemoryAlign(128, 128),
            (uint32_t)cellGcmGetLabelAddress(64)
            );

  In this sample, the synchronization process between RSX(R) and SPU is 
  performed as shown below:

  1. RSX(R) sends a notice to SPU for asking an acknowledgement of parameter 
     update process.
  2. SPU receives the notice and clears the notification area from RSX(R), 
     then writes into the address of the parameter to be updated.
  3. SPU sends a notice to RSX(R) indicating that the parameter update process
     is completed.
  4. RSX(R) receives the notice from SPU and sets the fragment program, then
     start rendering.
  5. After the rendering process is completed, RSX(R) clears the area used for 
     synchronization with SPU and sends a notice to SPU for asking an
     acknowledgement of update process, then the steps from 2. to 5. are
     repeated.

  Details of each steps from 1. to 5. are shown below:
  In step 1., cellGcmInlineTransfer() is executed to transfer the data of 
  uint32_t * 4 (0xbeefbeef, 0xbeefbeef, 0xbeefbeef, 0xbeefbeef).

  In step 2., SPU waits for a notice from RSX(R) using the following code in  
  duck_spu.cpp. After receiving the notice, it clears the area and writes into 
  the address.

        // wait notify from RSX
        while (1) {
            mfcGetData(read_label_buffer, spuparam.spu_read_label_addr, 16);
            if (read_label_buffer[0] == 0xbeefbeef) {
                for ( int i = 0; i < 4; i++)
                    read_label_buffer[i] = 0xcafecafe;
                // clear the buffer
                mfcPutData(read_label_buffer, spuparam.spu_read_label_addr, 16);
                break;
            }
        }
        mfcPutData(dma_buffer, buff_ea, size);

  In step 3., the following data is created to send a notice to RSX(R) 
  indicating that the  update process is completed:

        write_label_buffer[0] = 0xabcdabcd;
        write_label_buffer[1] = 0xabcdabcd;
        write_label_buffer[2] = 0xabcdabcd;
        write_label_buffer[3] = 0xabcdabcd;
        mfcPutData(write_label_buffer, spuparam.spu_write_label_addr, 16);

  After the notification process is completed, it waits until the expected 
  value is obtained similarly to step 2..

  In step 4., RSX(R) waits until the label area specified by 
  cellGcmSetWaitLabel(64, 0xabcdabcd) changes to the expected value so as to
  check whether the parameter is successfully updated by SPU. After the 
  notification is received, setShaderProgram() is executed to set the fragment
  program, then the rendering process is performed.

  In step 5., RSX(R) clears the area used for synchronization with SPU as 
  cellGcmSetWriteCommandLabel(64, 0xdddddddd). After that, it send a notice
  indicating the value held by SPU, then start the next rendering process.

<Files>
    Makefile      : Makefile
    disp.cpp      : Display configuration file
    disp.h        : Header file for display configuration
    fs.cpp        : File system operation file
    fs.h          : Header file for file system operation
    geometry.cpp  : Object rendering file
    geometry.h    : Header file for object rendering
    gtf.cpp       : File to read GTF texture
    gtf.h         : Header file to read GTF texture
    memory.cpp    : Local/main memory operation file
    memory.h      : Header file for local/main memory operation
    pad.cpp       : Controller operation file
    pad.h         : Header file for controller operation
    duck.cpp      : Main program
    readme_e.txt  : readme text file (English)
    readme_j.txt  : readme text file (Japanese)
    shader.cpp    : Shader program configuration file
    shader.h      : Header file for shader program configuration
    texture.cpp   : Texture configuration file
    texture.h     : Header file for texture configuration
    fpshader.cg   : Fragment shader program
    vpshader.cg   : Vertex shader program
    images/duck256.gtf : Texture for rendering object
    data/duck.smesh    : Geometry data for rendering object

<Running the Program>
    - Switching the rendering mode of rendering objects
        Triangle button    : Switch the rendering mode from polygon to line 
                             alternately.

    - Increasing/decreasing the number of rendering objects
        R1     : Increase the number of rendering objects by 1.
        R2     : Decrease the number of rendering objects by 1.

<Notes>
  This sample is created to use the header information output by sce-cgcdisasm
  in the main program, therefore some unnecessary processes are also included. 
  Please pay attention when building the sample into the application since it 
  is not described to make optimum use of hardware functions.
